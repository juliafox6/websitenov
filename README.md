# Вебсайт по аренде книг "Book-a-Book"

Данный вебсайт реализует следующие функции:

- Регистрация пользователя с полями: фамилия, имя, отчество, почта, пароль (с проверкой), номер телефона; выбор тарифа при регистрации;
- Тарифная система:
  
  | Тариф       | Сумма покупки | Дни аренды | Залог за 1 книгу | Штраф за просрочку |
  | ----------- | ------------- | ---------- | ---------------- | ------------------ |
  | Стандарт    | 10 000 у.е.   | 14 дней    | 2 000 у.е.       | 500 у.е.           |
  | Продвинутый | 15 000 у.е.   | 21 день    | 1 500 у.е.       | 300 у.е.           |
  | Премиум     | 20 000 у.е.   | 30 дней    | 1 000 у.е.       | 200 у.е.           |
- Каталог книг с отображением доступности книги в данный момент
- Система заказов:
  - Корзина для добавления книг
  - Выбор филиала при оформлении заказа
  - Проверка на баланс при оформлении (в т.ч. с замороженными депозитами)
  - Расчет залога
  - Различные статусы заказа: сборка, доставка, доставлен, возвращен (переносится в архивные заказы)
- Депозитная система:
  - депозитный счет пользователя (пополнение/снятие средств осуществлено через болванки, т.к. требует подключения банковской логики)
  - блокировка средств на время аренды книг
  - запрет на вывод заблокированных средств
- Процесс возврата книг:
  - проверка соблюдения сроков возврата
  - оценка состояния книг при возврате (через админ-панель)
  - система штрафов за просрочку или повреждение книги
  - автоматическая разблокировка депозита после возврата
  - списание штрафов из суммы депозита
- Личный кабинет:
  - отображение данных пользователя
  - информация о текущем тарифе
  - баланс депозитного счёта и операции с ним (вынесены в отдельную вкладку "Кошелёк")
  - история заказов

## Структура проекта:

- [adminboard](#панель-администратора)
  - static
    - [admin.css](#файл-admin-styles) (CSS file)
    - [admin.js](#файл-admin-scripts) (JavaScript file)
  - templates
    - [dashboard.html](#шаблон-dashboard) (HTML file)
    - [login.html](#шаблон-login-admin) (HTML file)
    - [order_detail.html](#шаблон-order-detail) (HTML file)
    - [user_detail.html](#шаблон-user-detail) (HTML file)
  - [admin.py](#главный-файл-панели-администратора) (Python Flask file)
- instance
  - [mainDB.db](#база-данных) (Database file)
- [static](#папка-static)
  - [src](#папка-src) (folder, contains images used in the main site)
  - [normalize.css](#файл-normalize) (CSS file)
  - [styles.css](#файл-styles) (CSS file)
  - [scripts.js](#файл-scripts) (JavaScript file)
- [templates](#папка-templates)
  - [index.html](#шаблон-index) (HTML file)
  - [booklist.html](#шаблон-booklist) (HTML file)
  - [book.html](#шаблон-book) (HTML file)
  - [signup.html](#шаблон-signup) (HTML file)
  - [login.html](#шаблон-login) (HTML file)
  - [profile.html](#шаблон-profile) (HTML file)
  - [cart.html](#шаблон-cart) (HTML file)
  - [wallet.html](#шаблон-wallet) (HTML file)
  - [order.html](#шаблон-order) (HTML file)
- [app.py](#главный-файл) (Python Flask file)
- [run_admin.py](#файл-run-admin) (Python Flask file)
- README.md (this file, markdown)

## Главный сайт

Файлы главного сайта расположены в корневой папке. Это - клиент-сторона сайта, доступная пользователям, взаимодействующая с БД. Для того, чтобы запустить сайт, нужно через интерпретатор `Python` запустить файл `app.py` из корневой папки и в терминале нажать на ссылку для открытия локального сервера на порте 5000. 

### База данных

Структура базы данных приведена в файле `app.py` (там же в комментариях рядом с полями написано, за что они отвечают), её ERP-диаграму можно увидеть в файлах проекта: [ERP-диаграмма](ERP.png).

База данных подключается и к главному сайту, и к панели администратора.

### Папка Static

Хранит в себе элементы сайта, не подлежащие рендеру через `Flask`, такие как скрипты, стили, а также изображения, применяемые в дизайне или встраиваемые в страницы сайта.

#### Папка SRC

В данной папке хранятся файлы и изображения, используемые в дизайне сайта. В `HTML`-файлах на них ведут ссылки.

#### Файл Normalize

Этот файл - какой-то файл из интернета, который сбрасывает все возможные стандартные настройки браузера по стилям CSS, чтобы оригинальные стили сайта работали сами по себе.

#### Файл Styles

В данном файле прописаны основные стили, которые применяются в `HTML`-элементам в их файлах. В основном, тут либо прописаны свойства для уже имеющихся элементов `HTML` - заголовки (`h`), параграфы (`p`), списки (`ul`, `ol`, элементы списков `li`), а также навигации (`nav`) и других функциональных элементов. Для кастомных стилей используются классы (оформленные как `.class`, примеры: `.card`, `.section`, `.member` и т.д.), которые позже добавляются в свойствах элементов `HTML` для того, чтобы применить к ним стиль (в формате `<html element class='class'>`).

#### Файл Scripts

В данном файле собраны основные `JavaScript`-функции, применяемые к различным действиям, производящимся пользователем на страницах сайта.

Функции в файле:

- `checkPassword()` - применяется в `HTML`-документе `signup.html` (регистрации), проверяет соответствие паролей в полях первичного и повторного ввода; применяется на изменение содержания поля (через `onchange=`)

- `checkFields()` - кастомная функция проверки заполненности полей при регистрации, также применяется через `onchange=`

- `submitAllForms()` - поскольку при регистрации форма информации о пользователе и форма выбора тарифа - две разные формы, кнопка для отправки вынесена вне форм, и на нажатие этой кнопки (`onclick=`) вызывается данный скрипт, который собирает данные с обеих форм для отправки запроса

- `toggleWalletForm()` - данный скрипт используется для отображения поля ввода суммы денег для вноса/вывода со счёта на странице кошелька

### Папка Templates

В данной папке содержатся шаблоны `HTML`-страниц для последующего рендера через `Flask`. В данные шаблоны уже встроены фрагменты кода для динамического отображения данных из БД на страницу.

На некоторых страницах (на `index.html`, `booklist.html` и `book.html`) осуществляется проверка на то, авторизован ли пользователь, потому что от этого зависит отображение вкладок в навигации и функционал данных страниц. На страницах `login.html` и `signup.html` данной проверки нет, потому что к ним имеет доступ только неавторизованный пользователь, а на всех остальных страницах (`cart.html`, `order.html`, `profile.html` и `wallet.html`) проверка не осуществляется, потому что через навигацию к ним имеет доступ только авторизованный пользователь.

#### Шаблон Index

`HTML` файл обычно делится на `head` и `body` части, где `head` - предопределенные параметры по типу заголовка страницы и кодировки:

```html
<title>Book-a-Book</title>
<meta charset='UTF-8'>
```

 снятия параметров устройства (для масштабирования адаптивного дизайна):

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

ссылок на файлы стилей и иконки сайта, отображающейся во вкладке сверху:

```html
<link href='../static/styles.css' rel='stylesheet'>
<link href='../static/src/icon.ico' rel='icon' type='image/x-icon'>
```

Далее в `body` прописана навигация, которая слегка отличается для различных страниц. Навигация также разнится для авторизованного и неавторизованного пользователя. Это можно видеть во встроенных командах для `Flask`, которые заключены в конструкцию `{% command %}`. Как здесь:

```html
{% if not current_user.is_authenticated %}
<a href='login.html' title='Войти'>Войти</a>
<a href='signup.html' title='Регистрация'>Регистрация</a>
{% endif %}
{% if current_user.is_authenticated %}
<a href='cart.html' title='Корзина'>Корзина ({{cart_count}})</a>
<a href='wallet.html' title='Счёт'>Кошелёк ({{current_user.deposit}})</a>
<a href='profile.html' title='Профиль'>Профиль</a>
<a href='logout.html' title='Выход'>Выход</a>
{% endif %}
```

В данной навигации динамически, путём забора данных из файла `app.py` и базы данных отображается количество товаров в корзине и текущий баланс на кошельке. Количество товаров в корзине высчитывается соответсвующей функцией в `app.py` и хранится там в виде переменной, а баланс кошелька берётся непосредственно из БД из данных текущего пользователя.

На странице `index.html` также есть другой блок встроенных команд для отображения нескольких книг в качестве примера в нижней секции.

#### Шаблон Booklist

Навигация в данном шаблоне аналогична предыдущему, однако в `booklist.html` выводятся все книги из библиотеки с помощью цикла `for`. Также предусмотрен вариант отображения для пустой библиотеки. Вот этот фрагмент кода:

```html
<div class="section light">
    {% if books %}
    {% for book in books %}
    <a href='book.html/{{ book.id }}' title='{{ book.title }}' class="member {% if not book.is_available %}unavailable{% endif %}">
        <div class="card member {% if not book.is_available %}unavailable{% endif %}">
              {% if book.image_url %}
              <img src='{{ book.image_url }}' alt='{{ book.title }}'>
              {% else %}
              <img src='../static/src/icon_plan1.png' alt='{{ book.title }}'>
              {% endif %}
              <h3>{{ book.title }}</h3>
              <p>{{ book.author }}</p>
              {% if not book.is_available %}
              <p class="availability-status">Недоступна</p>
              {% else %}
              <p class="availability-status available">Доступна</p>
              {% endif %}
          </div>
      </a>
      {% endfor %}
      {% else %}
      <p>Книги пока не добавлены</p>
      {% endif %}
</div>
```

Здесь мы видим динамически формирующуюся ссылку на книгу в зависимости от её `id` в базе данных. Все конструкции по типу `{{ book.id }}`, `{{ book.title }}` и т.д. подразумевают взятие данных из базы по запросу о конкретной книге, которая в данный момент рассматривается в текущей итерации цикла `for`.

Также здесь динамически меняется класс книги в зависимости от данных из БД о том, доступна она или нет.

#### Шаблон Book

Шаблон `book.html`, равно как и шаблон `order.html`, в первоначальном виде не отображается на сайте. Он отображается по ссылке `http://localhost:8888/book.html/{{ id }}`, где `id` индивидуален для каждой книги и генерируется динамически согласно данным про `id` и данные книги из БД.

На странице из БД подгружаются данные о книге. По кнопке "Добавить в корзину" происходит POST-запрос в базу данных, обрабатываемый в главном файле `app.py`.

#### Шаблон Signup

Это - страница регистрации на сайте. На данной странице динамически отображаются предупреждающие сообщения, которые управляются алгоритмом в главном файле `app.py`,  а также динамически подгружаются данные о тарифах из БД. Как упомянуто выше, личные данные пользователя и выбор тарифа разделены на два блока `div`, из-за чего формы тоже две. Поэтому кнопка отправки, отправляющая POST-запрос на создание нового пользователя в БД (также обрабатывается в `app.py`), вынесена за пределы этих форм, и на неё повешен скрипт из ранее упомянутого файла скриптов, собирающий данные с обоих форм. Также на каждом поле ввода висит скрипт на проверку заполненности полей.

#### Шаблон Login

Один из самых простых шаблонов. Единственное, что тут есть из встроенного кода для обработки при помощи `Flask` - вывод предупреждающих сообщений в случае неудачной попытки входа. По кнопке "Войти" отправляется запрос в БД для сверки введённых данных с существующими пользователями в таблице, который обрабатывается в главном файле `app.py`.

#### Шаблон Profile

Страница профиля доступна только для авторизованных пользователей. Она отображает все данные пользователя из БД, а также динамически подгружает списки его заказов. Как можно видеть в коде, заказы разбиты на `current_orders` и `order_history`, хотя при этом у нас всего одна таблица заказов в БД. Это связано с тем, что в главном файле `app.py`,  который будет разобран ниже, во время рендера шаблона профиля заранее производится заброс и фильтр заказов по статусу (возвращён/не возвращён), формируя два списка для вывода, которые впоследствии выводятся на страницу.

#### Шаблон Cart

Страница корзины. Принцип аналогичен предыдущему шаблону: сначала в главном файле происходит выборка товаров корзины, принадлежащих данному пользователю, после чего все товары корзины выводятся в список корзины через встроенный код в `HTML`-документе. Также предусмотрен вариант отображения сообщения о том, что корзина пуста.

Все переменные, выводящиеся с нижней секции слева (количество книг, общая сумма, срок аренды) также просчитываются в файле `app.py` во время рендера шаблона, чтобы их можно было использоваь внутри документа. Также в данном шаблоне реализована форма для отправки POST-запроса о создании нового заказа с возможностью выбора филиала (филиалы подгружаются из соответствующей таблицы в БД).

#### Шаблон Wallet

Шаблон кошелька. На нём выводятся все данные о текущем состоянии средств пользователя по принципу, аналогичному предыдущим двум шаблонам (предрасчёт в главном файле, затем вывод переменных внутри `HTML`-кода), аналогично профилю выводятся текущие заказы.

Выпадающее окно для вписания ссумы на вывод/пополнение, как было указано ранее, реализовано с помощью скрипта из файла скриптов. Сам интерфейс ввода/вывода средств представляет собой формы, которые при нажатии кнопки "Подтвердить" отправляют POST-запросы, которые обрабатываются также в функции рендера данного шаблона в файле `app.py`.

#### Шаблон Order

То же самое, что и шаблон Book, только с динамическим выводом данных уже о заказе, при этом выводимые данные могут меняться в зависимости от статуса заказа (если он уже доставлен, отображается также крайний срок аренды, если он возвращен, добавляется дата возвращения заказа пользователем).

### Главный файл

Файл `app.py` является главным исполняемым файлом всего веб-сайта. Он написан на языке `Python` с использованием фреймворка `Flask`, который позволяет создавать веб-приложения. В этом файле прописана вся логика работы сайта: от подключения к базе данных до обработки действий пользователя на страницах.

#### Структура файла

##### Импорт библиотек

В начале файла подключаются все необходимые библиотеки:

```python
from flask import *
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import UserMixin, LoginManager, login_user, login_required, current_user, logout_user
from datetime import datetime, date, timedelta
from decimal import Decimal
```

- `Flask` - основной фреймворк для создания веб-приложения
- `SQLAlchemy` - библиотека для работы с базой данных
- `Werkzeug.security` - инструменты для безопасного хранения паролей (хэширование)
- `Flask-Login` - управление авторизацией пользователей
- `datetime`, `date`, `timedelta` - работа с датами и временем
- `Decimal` - точные вычисления с денежными суммами

##### Инициализация приложения

```python
app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret-key-goes-here'
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///mainDB.db'
db = SQLAlchemy(app)
```

Здесь создается само приложение Flask, настраивается секретный ключ (нужен для безопасности сессий) и указывается путь к базе данных SQLite.

##### Настройка авторизации

```python
login_manager = LoginManager()
login_manager.login_view = 'login_post'
login_manager.init_app(app)

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))
```

Этот код настраивает систему входа пользователей. Функция `load_user` загружает информацию о пользователе по его ID при каждом запросе.

##### Модели базы данных

Далее определяются таблицы базы данных как классы Python:

###### Таблица тарифов (Tariff)

```python
class Tariff(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False) # Название тарифа
    cost = db.Column(db.Numeric(10, 2), nullable=False) # Стоимость тарифа при первой покупке
    deposit_per_book = db.Column(db.Numeric(10, 2), nullable=False) # Депозит за 1 книгу при данном тарифе
    rental_days = db.Column(db.Integer, nullable=False) # Количество дней аренды книги при данном тарифе
    penalty_per_day = db.Column(db.Numeric(10, 2), nullable=False) # Штраф за просрочку аренды при данном тарифе
```

###### Таблица пользователей (User)

```python
class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    last_name = db.Column(db.String(255), nullable=False) # Фамилия
    first_name = db.Column(db.String(255), nullable=False) # Имя
    patronymic = db.Column(db.String(255)) # Отчество
    email = db.Column(db.String(255), unique=True, nullable=False) # Почта
    phone = db.Column(db.String(20), nullable=False) # Телефон
    password_hash = db.Column(db.String(255), nullable=False) # Пароль (в хэш через wekzeug)
    deposit = db.Column(db.Numeric(10, 2), default=0.00) # Текущий баланс счета
    created_at = db.Column(db.DateTime, default=datetime.utcnow) # Времядата создания аккаунта
    tariff_id = db.Column(db.Integer, db.ForeignKey('tariff.id')) # Тариф, выбранный пользователем
```

И так далее для всех таблиц: Branch (филиалы), Book (книги), CartItem (корзина), Order (заказы), OrderItem (элементы заказа), DepositTransaction (операции с депозитом).

Каждая таблица имеет:

- Поля (columns) с указанием типа данных
- Внешние ключи (ForeignKey) для связи с другими таблицами
- Связи (relationships) для удобной работы с связанными данными

##### Начальные данные

Функция `create_initial_data()` заполняет базу данных первоначальной информацией:

- Три тарифа: Стандарт, Продвинутый, Премиум
- Три филиала: Центральный, Северный, Южный

##### Вспомогательные функции

###### Проверка доступности книги

```python
def is_book_available(book_id):
    """Проверяет, доступна ли книга для аренды (не находится в активном заказе)"""
    book = Book.query.get(book_id)
    if not book:
        return False

    # Сначала проверяем поле is_available в БД
    if not book.is_available:
        return False

    # Затем проверяем, есть ли книга в активных заказах (не возвращенных)
    active_order_items = OrderItem.query.join(Order).filter(
        OrderItem.book_id == book_id,
        Order.status != 'returned'
    ).first()
    return active_order_items is None
```

Эта функция проверяет, можно ли взять книгу в аренду, учитывая как общую доступность книги, так и её наличие в активных заказах.

##### Маршруты (Routes)

Маршруты - это URL-адреса, на которые реагирует приложение. Каждый маршрут связан с функцией, которая обрабатывает запрос.

###### Главная страница

```python
@app.route("/")
@app.route("/index.html")
def index():
    # Получаем несколько книг для отображения на главной
    featured_books = Book.query.limit(3).all()
    # Проверяем доступность каждой книги
    for book in featured_books:
        book.is_available = is_book_available(book.id)
    return render_template("index.html", current_user=current_user, featured_books=featured_books)
```

Функция получает 3 книги из базы, проверяет их доступность и передает в шаблон `index.html` для отображения.

###### Страница библиотеки

```python
@app.route("/booklist.html")
def booklist():
    books = Book.query.all()
    # Проверяем доступность каждой книги
    for book in books:
        book.is_available = is_book_available(book.id)
    return render_template("booklist.html", current_user=current_user, books=books)
```

Аналогично главной странице, но получает все книги из базы данных.

###### Страница отдельной книги

```python
@app.route("/book.html/<int:book_id>", methods=['GET', 'POST'])
def book_detail(book_id):
    book = Book.query.get_or_404(book_id)

    # Проверяем доступность книги
    book.is_available = is_book_available(book_id)

    if request.method == 'POST' and current_user.is_authenticated:
        action = request.form.get('action')
        if action == 'Добавить в корзину':
            # Проверяем доступность книги
            if not book.is_available:
                flash('Книга недоступна для аренды')
                return redirect(url_for('book_detail', book_id=book_id))

            # Проверяем, не добавлена ли уже книга в корзину
            existing_item = CartItem.query.filter_by(user_id=current_user.id, book_id=book_id).first()
            if not existing_item:
                cart_item = CartItem(user_id=current_user.id, book_id=book_id)
                db.session.add(cart_item)
                db.session.commit()
                flash('Книга добавлена в корзину')
            else:
                flash('Книга уже в корзине')
            return redirect(url_for('cart', book_id=book_id))
```

Эта функция обрабатывает как просмотр информации о книге (GET-запрос), так и добавление книги в корзину (POST-запрос). При добавлении в корзину проверяется доступность книги и отсутствие её уже в корзине пользователя.

###### Страница корзины

```python
@app.route("/cart.html", methods=['GET', 'POST'])
@login_required
def cart():
    if request.method == 'POST':
        action = request.form.get('action')

        if action == 'Удалить':
            # Удаление книги из корзины
            # ...
        elif action == 'Оформить заказ':
            # Создание нового заказа
            # Проверка наличия товаров в корзине
            # Проверка выбранного тарифа
            # Проверка выбранного филиала
            # Расчет общего депозита
            # Проверка баланса пользователя
            # Создание заказа в базе данных
            # Блокировка средств на депозите
            # Очистка корзины
            # ...
```

Функция корзины обрабатывает:

- Удаление книг из корзины
- Оформление заказа со всеми проверками и созданием записи в базе данных

###### Другие маршруты

Аналогичным образом работают остальные маршруты:

- `profile()` - страница профиля с историей заказов
- `order_detail()` - страница конкретного заказа
- `wallet()` - управление кошельком (пополнение/вывод средств)
- `signup_post()` - регистрация нового пользователя
- `login_post()` - авторизация пользователя
- `logout()` - выход из системы

##### Контекстный процессор

```python
@app.context_processor
def inject_cart_count():
    if current_user.is_authenticated:
        cart_count = CartItem.query.filter_by(user_id=current_user.id).count()
    else:
        cart_count = 0
    return dict(cart_count=cart_count)
```

Эта функция автоматически добавляет переменную `cart_count` (количество товаров в корзине) во все шаблоны, чтобы отображать актуальное количество в навигации.

##### Запуск приложения

```python
if __name__ == "__main__":
    app.run(host='127.0.0.1', port=5000, debug=True)
```

Код запускает веб-сервер на localhost порту 5000 в режиме отладки.

##### Инициализация базы данных

В комментариях указано, как создать базу данных:

```python
# Запуск базы данных:
# from app import app, db
# app.app_context().push()
# db.create_all()
# create_initial_data()
```

Эти команды нужно выполнить один раз перед первым запуском приложения, чтобы создать файл базы данных и заполнить его начальными данными.

Этот файл является "сердцем" всего веб-сайта, связывающим интерфейс пользователя с базой данных и реализующим всю бизнес-логику аренды книг.

## Панель администратора

Панель администратора сделана для того, чтобы можно было регулировать операции с точки зрения сервиса. Сервис-сторона, другими словами. Была возможность реализации этих функций через добавление поля в БД `is_admin`,  которое бы открывало пользователю возможность пользоваться интерфейсом администратора. Однако это бы только больше нагромоздило существующий код основного сайта, да и в целом это всё равно целый отдельный интерфейс, поэтому его было решено вынести за пределы основного сайта.

Папки static и templates здесь имеют то же значение, что и для основного сайта.  

#### Файл Admin Styles

В целом, аналогично файлу стилей основного сайта: просто содержит декларированное оформление и стили для элементов панели администратора, которые позже применяются к `HTML`-элементам.

#### Файл Admin Scripts

В данном файле собраны основные `JavaScript`-функции, применяемые к различным действиям, производящимся администратором в панели.

Функции в файле:

- **Обработка формы добавления книги** - отслеживает отправку формы добавления новой книги в библиотеку, отправляет данные на сервер через API-эндпоинт `/api/add_book` и отображает сообщение о результате операции (успех/ошибка)

- **Обработка формы поиска пользователя** - реализует функционал поиска пользователей по различным критериям (имя, email, телефон), отправляет запрос на `/api/search_users` и динамически отображает результаты поиска в виде карточек пользователей

- **Обработка формы смены тарифа** - позволяет администратору изменить тариф пользователя, отправляет запрос на `/api/change_tariff` и обновляет страницу после успешного выполнения

- **Обработка формы смены статуса заказа** - обрабатывает изменение статуса заказа (сборка, доставка, доставлен, возвращен) через API-эндпоинт `/api/change_order_status`, поддерживает множественные формы на странице

- **Обработка формы оценки повреждений** - реализует функционал оценки состояния книг при возврате, включает подтверждение действия перед отправкой данных на `/api/assess_damage`, так как операция влияет на финансовые расчеты с пользователем

- **`showMessage()`** - вспомогательная функция для отображения временных сообщений о 
  результате операций (успех/ошибка) с автоматическим скрытием через 5 
  секунд

- **`displaySearchResults()`** - функция для динамического отображения результатов поиска 
  пользователей в виде карточек с основной информацией и ссылкой для 
  управления конкретным пользователем

#### Шаблон Dashboard

Это главная страница панели администратора, доступная после успешной авторизации. Шаблон разделен на две основные секции управления.

В верхней секции "Добавить новую книгу" находится форма с полями для ввода информации о книге: название, автор, жанр, язык, издательство, описание и URL обложки. Форма использует `JavaScript` для асинхронной отправки данных на сервер без перезагрузки страницы (из файла скриптов).

Нижняя секция "Поиск пользователей" содержит форму поиска по имени или фамилии пользователя. Результаты поиска динамически отображаются в блоке `searchResults` в виде карточек пользователей с основной информацией и ссылкой для управления.

В шапке страницы расположена кнопка выхода из системы, которая перенаправляет на страницу выхода.

#### Шаблон Login Admin

Страница входа в панель вообще не содержит почти ничего, кроме центрированной формы авторизации. Форма содержит единственное поле для ввода пароля. Пароль предопределён в коде программы в главном файле панели администратора `admin.py` и может быть изменён (либо захеширован аналогично паролям пользователей в БД, через библиотеку `werkzeug.security`)

При наличии сообщений об ошибках (например, при вводе неверного пароля) они выводятся над формой входа через механизм flash-сообщений `Flask` (с таким уже встречались на страницах главного сайта. После успешной авторизации пользователь перенаправляется на главную страницу панели управления.

#### Шаблон Order Detail

Страница детализации заказа предназначена для оценки состояния возвращенных книг и обработки возврата депозита. В верхней части отображается основная информация о заказе: данные пользователя, филиал, сумма депозита, статус и срок возврата.

Основная секция содержит форму оценки повреждений для каждой книги в заказе. Для каждой книги можно выбрать степень повреждения из трех вариантов: "Не повреждена" (без штрафов), "Повреждена" (удерживается половина депозита) или "Не подлежит восстановлению" (удерживается полный депозит).

При отправке формы появляется подтверждающее диалоговое окно, после чего система рассчитывает итоговую сумму к возврату с учетом штрафов за повреждения и разблокирует оставшиеся средства на счете пользователя.

#### Шаблон User Detail

Страница управления конкретным пользователем содержит три основные секции. Первая секция отображает личную информацию о пользователе: ФИО, контактные данные, текущий баланс депозита и выбранный тариф.

Во второй секции расположена форма изменения тарифа пользователя с выпадающим списком доступных тарифов. Изменение тарифа применяется немедленно и влияет на условия будущих заказов.

Третья секция показывает историю заказов пользователя. Для каждого заказа отображается основная информация и предоставляются инструменты управления: изменение статуса заказа через выпадающий список и кнопка "Оценить повреждения" для доставленных заказов, которая ведет на страницу детализации заказа.

Все формы на странице используют асинхронные запросы через JavaScript для обновления данных без перезагрузки страницы.

### Главный файл панели администратора

Файл `admin.py` является основным исполняемым файлом панели администратора. Это отдельное `Flask`-приложение, которое работает параллельно с основным сайтом и предоставляет интерфейс для управления системой аренды книг.

#### Структура файла

##### Импорт библиотек и настройка путей

```python
from flask import Flask, render_template, request, redirect, url_for, session, flash, jsonify
from datetime import datetime, date
from decimal import Decimal
import sys
import os

# Добавляем родительскую директорию в путь для импорта моделей
parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, parent_dir)
```

Особенность этого файла в том, что он использует те же модели базы данных, что и основной сайт. Для этого добавляется родительская директория в путь импорта Python, чтобы можно было импортировать модели из основного приложения.

##### Импорт моделей из основного приложения

```python
from app import db, User, Book, Order, OrderItem, Tariff, DepositTransaction, Branch
```

Здесь импортируются все необходимые модели базы данных из основного приложения, что позволяет административной панели работать с той же базой данных, что и основной сайт.

##### Инициализация Flask приложения

```python
app = Flask(__name__)
app.config['SECRET_KEY'] = 'admin-secret-key-here'
```

Создается отдельное Flask-приложение для админки с собственным секретным ключом. Это важно для изоляции сессий между основным сайтом и панелью администратора.

##### Настройки сессии

```python
app.config['SESSION_COOKIE_NAME'] = 'admin_session'
app.config['SESSION_COOKIE_PATH'] = '/'
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SECURE'] = False  # False для разработки
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
app.config['PERMANENT_SESSION_LIFETIME'] = 3600  # 1 час в секундах
```

Эти настройки обеспечивают, что сессии основного сайта и админки не конфликтуют между собой. Куки админки имеют уникальное имя `admin_session`. Также они позволяют удерживать сессию администратора открытой, без необходимости авторизовываться после каждого изменения, при этом закрывая сессию автоматически в течение часа.

##### Подключение к базе данных

```python
db_path = os.path.join(parent_dir, 'instance', 'mainDB.db')
app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'
db.init_app(app)
```

Админка подключается к той же базе данных, что и основной сайт (`mainDB.db`), что позволяет обоим приложениям работать с одними и теми же данными.

##### Аутентификация администратора

```python
ADMIN_PASSWORD = "12345"

def admin_required(f):
    def decorated_function(*args, **kwargs):
        if not session.get('admin_logged_in'):
            return redirect(url_for('admin_login'))
        return f(*args, **kwargs)
    return decorated_function
```

Реализована простая система аутентификации с фиксированным паролем. Декоратор `@admin_required` защищает маршруты, требующие авторизации администратора.

#### Маршруты админки

##### Страница входа

```python
@app.route('/', methods=['GET', 'POST'])
def admin_login():
    if request.method == 'POST':
        password = request.form.get('password')
        if password == ADMIN_PASSWORD:
            session['admin_logged_in'] = True
            return redirect(url_for('dashboard'))
        else:
            flash('Неверный пароль')
    return render_template('login.html')
```

Простая форма входа с проверкой пароля. При успешной авторизации устанавливается флаг в сессии и происходит перенаправление на панель управления.

##### Панель управления

```python
@app.route('/dashboard')
@admin_required
def dashboard():
    return render_template('dashboard.html')
```

Главная страница админки, доступная только авторизованным администраторам. Здесь отображаются основные инструменты управления.

##### API для добавления книг

```python
@app.route('/api/add_book', methods=['POST'])
@admin_required
def add_book():
    title = request.form.get('title')
    author = request.form.get('author')
    genre = request.form.get('genre')
    # ... получение остальных полей

    new_book = Book(
        title=title,
        author=author,
        genre=genre,
        # ... инициализация остальных полей
    )
    db.session.add(new_book)
    db.session.commit()
    return jsonify({'success': True, 'message': 'Книга успешно добавлена'})
```

API-эндпоинт для добавления новых книг в библиотеку. Принимает данные из формы и создает новую запись в таблице книг.

##### Поиск пользователей

```python
@app.route('/api/search_users', methods=['POST'])
@admin_required
def search_users():
    search_query = request.form.get('query', '').strip()
    users = User.query.filter(
        (User.first_name.ilike(f'%{search_query}%')) |
        (User.last_name.ilike(f'%{search_query}%'))
    ).all()
    return jsonify({'success': True, 'users': users_data})
```

Функция поиска пользователей по имени или фамилии. Использует нечеткий поиск для нахождения совпадений и возвращает результаты в формате JSON для динамического отображения на странице.

##### Управление пользователями

```python
@app.route('/user/<int:user_id>')
@admin_required
def user_detail(user_id):
    user = User.query.get_or_404(user_id)
    tariffs = Tariff.query.all()
    orders = Order.query.filter_by(user_id=user_id).order_by(Order.created_at.desc()).all()
    return render_template('user_detail.html', user=user, tariffs=tariffs, orders=orders)
```

Страница детальной информации о пользователе, где администратор может просматривать данные пользователя, изменять его тариф и управлять заказами.

##### Изменение статусов заказов

```python
@app.route('/api/change_order_status', methods=['POST'])
@admin_required
def change_order_status():
    order_id = request.form.get('order_id')
    new_status = request.form.get('status')
    order = Order.query.get_or_404(order_id)

    if new_status == 'delivered' and not order.picked_up_at:
        order.picked_up_at = datetime.utcnow()

    order.status = new_status
    db.session.commit()
    return jsonify({'success': True, 'message': 'Статус заказа изменен'})
```

API для изменения статуса заказа. При установке статуса "доставлен" автоматически проставляется дата получения заказа.

##### Оценка повреждений книг

```python
@app.route('/api/assess_damage', methods=['POST'])
@admin_required
def assess_damage():
    order_id = request.form.get('order_id')
    order = Order.query.get_or_404(order_id)
    order_items = OrderItem.query.filter_by(order_id=order_id).all()

    total_fee = Decimal(0)
    for item in order_items:
        damage_ratio = request.form.get(f'damage_{item.id}', '0')
        item.damage_ratio = damage_ratio

        if damage_ratio == '1':
            total_fee += deposit_per_book / 2
        elif damage_ratio == '2':
            total_fee += deposit_per_book

    return_amount = order.total_deposit - total_fee
    order.status = 'returned'
    db.session.commit()
```

Один из самых важных эндпоинтов - обработка возврата книг и оценка их состояния. Система рассчитывает штрафы за повреждения и возвращает пользователю остаток депозита после вычета штрафов.

#### Запуск приложения

```python
if __name__ == '__main__':
    app.run(host='127.0.0.1', port=8000, debug=True, use_reloader=False)
```

Админка запускается на порту 8000 (в отличие от основного сайта на порту 5000), что позволяет обоим приложениям работать одновременно на одном компьютере. **Но** на самом деле - не позволяет.

### Файл Run Admin

Данный файл находится в корне проекта. Всё, что он собой представляет, это пара строчек кода:

```python
from adminboard.admin import app

if __name__ == '__main__':
    app.run(port=5001, debug=True)
```

Зачем он нужен? Дело в том, что запуская файл `admin.py` через интерпретатор `Python` в его изначальной папке adminboard, он игнорирует настройки порта и пытается запуститься на тот же порт, что и `main.py`. А если мы хотим параллельно запускать оба интерфейса: и пользовательский, и сервисный, то нам нужно запускать их по одному и тому же адресу - то есть, из корневой папки. Для этого существуте файл `run_admin.py`, и именно с помощью него нужно запускать панель администратора.
